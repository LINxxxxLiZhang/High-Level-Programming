<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>tiny_vs</name></assembly>
<members>
<member name="M:App.Common.isOpInList(System.Char,Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 character op is in list lst
</summary>
</member>
<member name="M:App.Common.isAlphaNum(System.Char)">
<summary>
 character is alphanumeic (allowed in symbol)
</summary>
</member>
<member name="M:App.Common.isDigit(System.Char)">
<summary>
 character is a decimal digit
</summary>
</member>
<member name="M:App.Common.isAlpha(System.Char)">
<summary>
 character is alphabetic
</summary>
</member>
<member name="M:App.Common.isNewLine(System.Char)">
<summary>
 charater is new line
</summary>
</member>
<member name="M:App.Common.isWhiteSpace(System.Char)">
<summary>
 character is white sppace
</summary>
</member>
<member name="P:App.Common.allOps">
<summary>
 any token string with a special meaning
</summary>
</member>
<member name="P:App.Common.binaryOps">
<summary>
 strings used for binary 0perators
</summary>
</member>
<member name="P:App.Common.binaryOpPriority">
<summary>
 // this list defines which operators are binary and establishes operator precedence (binding)
</summary>
</member>
<member name="P:App.Common.unaryOps">
<summary>
 prefix unary operators (may also be binary in LeftD context)
</summary>
</member>
<member name="P:App.Common.startOps">
<summary>
 start of recursive constructs
</summary>
</member>
<member name="P:App.Common.endOps">
<summary>
 end of parse recursive constructs
</summary>
</member>
<member name="M:App.Parser.|PREC|_|(Microsoft.FSharp.Collections.FSharpList{App.Common.Token})">
<summary>
 Partial Active Pattern to parse a recursive construct bracketed by keywords or brackets
 This handles all recursive parsing, with input token list toks and return exp,restOfToks
 Sub-patterns here parse parts of a construct with input toks and output exp,restOfToks
 Chained sub-patterns can match different subexpressions in e.g. IF THEN ELSE FI construct.
</summary>
</member>
<member name="P:App.Parser.|PEXP|_|">
<summary>
 Partial Active Pattern equivalent to ParseExpression
</summary>
</member>
<member name="M:App.Parser.|PNullD|_|(Microsoft.FSharp.Collections.FSharpList{App.Common.Token})">
<summary>
 Partial Active Pattern equivalent to NullD
</summary>
</member>
<member name="M:App.Parser.NullD(Microsoft.FSharp.Collections.FSharpList{App.Common.Token})">
<summary>
 Parse a single token from toks as an expression.
 If the token starts a recursive construct parse the whole construct
 Return parse result * unparsed tokens
</summary>
</member>
<member name="M:App.Parser.LeftD(App.Common.Exp,Microsoft.FSharp.Collections.FSharpList{App.Common.Token})">
<summary>
 Interpret next token as an operator in left denotation context.
 Parse the RH operand, if operator is binary.
 Return the parse result * unparsed tokens
</summary>
</member>
<member name="M:App.Parser.ParseExpression(System.Int32,Microsoft.FSharp.Collections.FSharpList{App.Common.Token})">
<summary>
 Parse toks as an expression until binding drops below rbPrio
 Return parse result * unparsed tokens
 Uses Pratt parsing algorithm
</summary>
</member>
<member name="M:App.Parser.RBinding(App.Common.Token)">
<summary>
 right binding of a token determining operator precedence
</summary>
</member>
<member name="M:App.Parser.LBinding(App.Common.Token)">
<summary>
 left binding of a token determining operator precedence
</summary>
</member>
<member name="M:App.Parser.unaryBinding(App.Common.Token)">
<summary>
 binding precedence for unary operators
</summary>
</member>
<member name="P:App.Parser.applyBinding">
<summary>
 binding precedence for functional application
</summary>
</member>
<member name="M:App.Parser.toExp(App.Common.Token)">
<summary>
 for a token representing a value, convert it into the equivalent Exp
</summary>
</member>
<member name="M:App.Parser.makePP``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0)">
<summary>
 convert predicate into a partial pattern function which returns its input unchanged
</summary>
</member>
<member name="P:App.Parser.isEndTok">
<summary>
 token is a recursive parse construct end marker
</summary>
</member>
<member name="P:App.Parser.isUnaryTok">
<summary>
 token is a unary operator   
</summary>
</member>
<member name="P:App.Parser.isBinaryTok">
<summary>
 token is a binay operator
</summary>
</member>
<member name="M:App.Parser.isLitTok(App.Common.Token)">
<summary>
 token is a literal value
</summary>
</member>
<member name="M:App.Parser.isTokInList(Microsoft.FSharp.Collections.FSharpList{System.String},App.Common.Token)">
<summary>
 token is TokName s where s is in list lst
</summary>
</member>
<member name="P:App.Reducer.BuiltInFuncs">
<summary>
 combinators and other functions that are built in
</summary>
</member>
<member name="M:App.Reducer.ISPAIRReduce(Microsoft.FSharp.Core.FSharpFunc{System.Boolean,App.Reducer.Data},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}},System.Int32)">
<summary>
 ISPAIR returns true only for its single parameter a pair
</summary>
</member>
<member name="M:App.Reducer.FReduce``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}},``0)">
<summary>
 F combinator used for &quot;false&quot; in ITE
</summary>
</member>
<member name="M:App.Reducer.SReduce``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}},``0)">
<summary>
 S combinator
</summary>
</member>
<member name="M:App.Reducer.KReduce``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}},``0)">
<summary>
 K combinator
</summary>
</member>
<member name="M:App.Reducer.IReduce``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}},``0)">
<summary>
 I combinator
</summary>
</member>
<member name="M:App.Reducer.reduce(System.Int32,Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data})">
<summary>
 Perform normal order combinator beta reduction on root until top-level tree is irreducible
 n: level of recursive calls to reduce (controls print indentation)
 root:
</summary>
</member>
<member name="M:App.Reducer.makeHeap(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data}}},App.Common.Exp)">
<summary>
 Convert an expression into a graph suitable for reduction
 Note how Apply lst gets transformed into a list of binary DApply cells
 Names are looked up in envt and turned into ref cells of implementations
 In the case of recursive functions these cells are over-written by the 
 correct implementation after the graph as been created.
 Normal call: makeHeap BuiltinFuncs
</summary>
</member>
<member name="M:App.Reducer.listBracketAbstract(Microsoft.FSharp.Collections.FSharpList{App.Common.Exp},App.Common.Exp)">
<summary>
 Abstract each element of vl from exp in list order
</summary>
</member>
<member name="M:App.Reducer.bracketAbstract(App.Common.Exp,App.Common.Exp)">
<summary>
 Bracket abstraction
 [v] exp: abstract name v from expression exp, using combinators
 ([v] exp) v = exp
</summary>
</member>
<member name="M:App.Reducer.DEquals(App.Reducer.Data,App.Reducer.Data)">
<summary>
 Equality on graphs - all combinators and trees are treated as non-equal
 Immediate (not-tree) data is correctly compared
 DNull is not equal to any pair (which is a P function application), but equal to DNull
 function applications are always not equal
</summary>
</member>
<member name="M:App.Reducer.DApply(Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data},Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data})">
<summary>
 a binary cell in the graph representing a (possibly Curried) function application.
</summary>
</member>
<member name="M:App.Reducer.ppL(Microsoft.FSharp.Core.FSharpRef{App.Reducer.Data})">
<summary>
 pretty-print function for possibly cyclic graphs
</summary>
</member>
<member name="M:App.Tokeniser.charListStartsWith(Microsoft.FSharp.Collections.FSharpList{System.Char},System.String)">
<summary>
 Utility match function characters in str match a starting prefix of x
</summary>
</member>
</members>
</doc>
